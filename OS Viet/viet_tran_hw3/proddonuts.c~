
#include <stdlib.h>
#include <stdio.h>

#include "donuts.h"

int		shmid, semid[3];
void		sig_handler (int);

int main(int argc, char *argv[])
{
	int	in_ptr [NUMFLAVORS];
	int	serial [NUMFLAVORS];
	int	i,j,k;
	struct donut_ring *shared_ring;
	struct timeval randtime;
/* producer initializes serial counters and in-pointers  */
	for(i = 0; i < NUMFLAVORS; i++){
		in_ptr [i] = 0;
		serial [i]  = 0;
	}
/**  begin syscall signal comment for signal handling 
     #include <signal.h>

     int   sigaction(int sig, struct sigaction *new_action, 
			      struct sigaction *old_action);

     struct sigaction{
        void    	(*sa_handler)();
        sigset_t 	sa_mask;
        int     	sa_flags;
     };

     sigemptyset	(sigset_t *mask);
     sigfillset		(sigset_t *mask);
     sigaddset		(sigset_t *mask, int SIGNAL);
     sigdelset		(sigset_t *mask, int SIGNAL);

          SIGHUP    	1    	hangup
          SIGINT    	2    	interrupt
          SIGQUIT  	3*   	quit
          SIGILL    	4*   	illegal instruction
          SIGTRAP 	5*   	trace trap
          SIGABRT 	6*   	abort (generated by abort(3) routine)
          SIGEMT    	7*   	emulator trap
          SIGFPE    	8*   	arithmetic exception
          SIGKILL   	9    	kill (cannot be caught, blocked, or ignored)
          SIGBUS    	10*	bus error
          SIGSEGV 	11*	segmentation violation
          SIGSYS    	12*	bad argument to system call
          SIGPIPE   	13   	write on a pipe with no reader
          SIGALRM	14  	alarm clock
          SIGTERM 	15 	software termination signal

************* end syscall signal comment ******/



/****** only need to catch some signals *****/

   sigset_t   mask_sigs;
   int  nsigs;
   struct sigaction new;
   int sigs [] = {SIGHUP, SIGINT, SIGQUIT, SIGBUS, 
                        SIGTERM, SIGSEGV, SIGFPE};

   nsigs = sizeof (sigs) / sizeof (int);
   sigemptyset (&mask_sigs);
   for(i=0; i< nsigs; i++)
       sigaddset (&mask_sigs, sigs [i]);       
   for(i = 0; i <  nsigs; i++){
      new.sa_handler 	= sig_handler;
      new.sa_mask 	= mask_sigs;
      new.sa_flags 	= 0;
      if(sigaction (sigs [i], &new, NULL) == -1){
         perror("can't set signals: ");
         exit(1);
      }
   }



/*** begin syscall shmget comment for shared memory
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/shm.h>

     int shmget(key_t key, size_t size, int shmflg)

************* end syscall shmget comment ******/


	if((shmid = shmget (MEMKEY, sizeof(struct donut_ring),
			            IPC_CREAT | 0600)) == -1){
		perror("producer shared get failed: ");
		exit(1);
	}

/***  begin syscall shmat comment for shared memory
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/shm.h>

     void *shmat (int shmid, const void *attach_addr, 
					   int shmflg);

************* end syscall shmat comment ******/

	if((shared_ring = (struct donut_ring *) 
			   shmat (shmid, NULL, 0)) == -1){
		perror("producer shared attach failed: ");
		sig_handler(-1);
	}



/***  begin syscall semget comment for semaphores
     #include <sys/types.h>
     #include <sys/ipc.h>
     #include <sys/sem.h>

     int semget (key_t key, int nsems, int semflg);

************* end syscall semget comment ******/


	for(i=0; i<NUMSEMIDS; i++)
		if ((semid[i] = semget (SEMKEY+i, NUMFLAVORS, 
					 IPC_CREAT | 0600)) == -1){
		perror("semaphore allocation failed: ");
		sig_handler(-1);
	}



/***  begin syscall gettimeofday comment for time seed
     #include <sys/time.h>

     int gettimeofday (struct timeval *tp, struct timezone *tzp);

     struct timeval {
		long    tv_sec;         	/* seconds 
        	long    tv_usec;        	/* and microseconds 
     }

********* end syscall gettimeofday comment ******/


	//gettimeofday (&randtime, (struct timezone *)0);

/* use microsecond component for uniqueness */

	//unsigned short xsub1[3];
        //xsub1[0] = (ushort) randtime.tv_usec;
        //xsub1[1] = (ushort)(randtime.tv_usec >> 16);
        //xsub1[2] = (ushort)(getpid());

/* use nrand48 with xsub1 to get 32 bit random number */

	// j=nrand48(xsub1) & 3;


/* use the semsetall utility to set initial semaphore values */

	if(semsetall (semid [PROD], 
			   NUMFLAVORS, 	NUMSLOTS) == -1){
                perror("semsetsall failed: ");
                sig_handler(-1);
	}
	if(semsetall (semid [CONSUMER], 
			   NUMFLAVORS, 	0) == -1){
                perror("semsetsall failed: ");
                sig_handler(-1);
        }
	if(semsetall (semid [OUTPTR], 
			   NUMFLAVORS, 	1) == -1){
	  perror("semsetsall failed: ");
                sig_handler(-1);
        }
/*  the rest of the producer/consumer code follows,   */
/*  including the producer signal handler below       */

	while(1){	

	  gettimeofday (&randtime, (struct timezone *)0);
	  unsigned short xsub1[3];
	  xsub1[0] = (ushort) randtime.tv_usec;
	  xsub1[1] = (ushort)(randtime.tv_usec >> 16);
	  xsub1[2] = (ushort)(getpid());
	  j = nrand48(xsub1) & 3;	  

	  p(semid[PROD], j);	
	  
	  serial[j] = serial[j] + 1;
	  shared_ring->flavor[j][in_ptr[j]] = serial[j];	  
	  in_ptr[j] = (in_ptr[j] + 1) % NUMSLOTS;

	  v(semid[CONSUMER], j);	 

	}
}

void    sig_handler(int sig)
{
	int	i,j,k;

	printf("In signal handler with signal # %d\n",sig);

	if(shmctl(shmid, IPC_RMID, 0) == -1){
		perror("handler failed shm RMID: ");
	}
	for(i = 0; i < NUMSEMIDS; i++){
	  if(semctl (semid[i], 0, 
 			    IPC_RMID, 0) == -1){
		perror("handler failed sem RMID: ");
	  }
	}
        exit(5);
}

