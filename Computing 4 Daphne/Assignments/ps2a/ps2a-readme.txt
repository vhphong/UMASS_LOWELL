#Name: Dangnhi Ngoc Ngo	This assignment is about linear feedback shift register.In my program, I have created a constructor that initializes the seed and the tap position. Seed is a String argument whose characters are a sequence of 0s and 1s. The bits will be shifted to the left 1 position, and the vacated bit will be replaced by the exclusive or the first bit and the tap bit. The function step() returns the bit at the vacated position.In addition, the function generate(int k) will simulate k steps and return k-bit integer.For example, I have chosen 3 cases for this program:1/ Register bits: 0110011, and tap position: 4We respectively shift bits to the left 1 position, the output would be:1100111 11001111 10011111 10111111 11111111 11111110 01111100 01111000 01110000 01100000 01000001 1If we provoke method generate(5), we should calculate 5-bit integer for "1111111", and the result is 31 (2^4+2^3+2^2+2^1+2^0)2/ Register bits: 00101000110010, and tap position: 11We respectively shift bits to the left 1 position, the output would be:01010001100101 110100011001010 001000110010100 010001100101000 000011001010001 100110010100010 001100101000101 111001010001011 110010100010111 1If we provoke method generate(7), we should calculate 7-bit integer for "01100101000101", and the result is 69 (2^6+2^2+2^0)2/ Register bits: 0111, and tap position: 2We respectively shift bits to the left 1 position, the output would be:1111 11110 01100 01000 00001 1If we provoke method generate(3), we should calculate 3-bit integer for "1100", and the result is 4 (2^2)The reason why I have chosen these representation register bits is that "0010100011001" represents for long string bits (13 bits), "0111" represents for short string bits (4 bits) and "0110011" has 7 bits that has the mid length compared to two register bits above.With the BOOST_AUTO_TEST_CASE, we test, with the initial register bits and tap position, whether the function step() prints out the vacated bit is equal with our computation (value 0s or 1s). Simultaneously, it tests if the function generate() can compute exactly the integer when we simulate k steps.For example:The register bits: 0111, and tap position: 2BOOST_REQUIRE(lfsr.step()==1); This one test that if we provoke step() once, the new bit is equal to 1 or not. If it is 1, there will be no error.BOOST_REQUIRE(lfsr.step()==0);And when we provoke step() one more time, the new bit would be 0 and cause no errorBOOST_REQUIRE(lfsr2.generate(3)==4);This function means that if we provoke generate() with k = 3, it will simulate 3 steps and compute 4. If the result is equal to 4, there is no error.The result printed out after running my program is:Running 4 test cases...*** No errors detected