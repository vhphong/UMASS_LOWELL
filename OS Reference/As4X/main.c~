#include "project_header.h"

DonutStore 			the_store;
pthread_t			thread_id[NUMCONSUMERS+PRODUCERS], sig_wait_id;

pthread_mutex_t		prod[NUMFLAVORS];
pthread_mutex_t 	cons[NUMFLAVORS];
pthread_cond_t		prod_cond[NUMFLAVORS];
pthread_cond_t		cons_cond[NUMFLAVORS];

int  main(int argc, char *argv[])
{
	short						i, k, nsigs;
	int						first_consumer_thread_index;
	int j;
	char					msg[300];
	char					wr_buf[256];
	struct timeval			randtime, first_time, last_time;
	struct sched_param 		sched_struct;
	int						arg_array[NUMPRODUCERS + NUMCONSUMERS];
	sigset_t				all_signals;
	pthread_attr_t			thread_attr;
	struct sigaction		new;
	unsigned int			cpu;
	int						proc_cnt = 0;
	int 					proc_cntx, cn;
	float					etime;
	ushort					xsub1[3];
	cpu_set_t				mask;

	int sigs[] = { SIGPIPE, SIGBUS, SIGSEGV, SIGFPE };

	gettimeofday(&randtime, (struct timezone *)0);

	xsub1[0] = (ushort)randtime.tv_usec;
	xsub1[1] = (ushort)(randtime.tv_usec >> 16);
	xsub1[2] = (ushort)(getpid());

	// sched_getaffinity gets the id of a thread, and based on the id of the thread
	// it goes about finding the cpu set. It fills in a bit vector (ours is named mask) 
	// for every cpu we find available to the thread we're asking about.  
	sched_getaffinity(syscall(SYS_gettid), sizeof(cpu_set_t), &mask);
	for (i = 0; i < CPU_CK_COUNT; i++)
		proc_cnt += (CPU_ISSET(i, &mask)) ? 1 : 0;

	sprintf(msg, "\nThis run will have\n Producers = %d\n Consumers = %d\n Qdepth  = %d\n Cons dozens = %d\n Donut flav = %d\n Thrd Scope %s\n Number CPUs = %d\n", NUMPRODUCERS, NUMCONSUMERS, NUMSLOTS, NUM_DOZ_TO_CONS, NUMFLAVORS, "Process", proc_cnt);
	write(STDOUT, msg, strlen(msg));

/*
	printf("\nPROCESS AFFINITY MASK BEFORE ADJUSTMENT:\n");
	printf(" CPUS : 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23\n");

	sprintf(wr_buf, " %s: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n", "    ",
		(CPU_ISSET(0, &mask)) ? 1 : 0,
		(CPU_ISSET(1, &mask)) ? 1 : 0,
		(CPU_ISSET(2, &mask)) ? 1 : 0,
		(CPU_ISSET(3, &mask)) ? 1 : 0,
		(CPU_ISSET(4, &mask)) ? 1 : 0,
		(CPU_ISSET(5, &mask)) ? 1 : 0,
		(CPU_ISSET(6, &mask)) ? 1 : 0,
		(CPU_ISSET(7, &mask)) ? 1 : 0,
		(CPU_ISSET(8, &mask)) ? 1 : 0,
		(CPU_ISSET(9, &mask)) ? 1 : 0,
		(CPU_ISSET(10, &mask)) ? 1 : 0,
		(CPU_ISSET(11, &mask)) ? 1 : 0,
		(CPU_ISSET(12, &mask)) ? 1 : 0,
		(CPU_ISSET(13, &mask)) ? 1 : 0,
		(CPU_ISSET(14, &mask)) ? 1 : 0,
		(CPU_ISSET(15, &mask)) ? 1 : 0,
		(CPU_ISSET(16, &mask)) ? 1 : 0,
		(CPU_ISSET(17, &mask)) ? 1 : 0,
		(CPU_ISSET(18, &mask)) ? 1 : 0,
		(CPU_ISSET(19, &mask)) ? 1 : 0,
		(CPU_ISSET(20, &mask)) ? 1 : 0,
		(CPU_ISSET(21, &mask)) ? 1 : 0,
		(CPU_ISSET(22, &mask)) ? 1 : 0,
		(CPU_ISSET(23, &mask)) ? 1 : 0);

	write(1, wr_buf, strlen(wr_buf)); */

	// clear out our bit vector
	CPU_ZERO(&mask);
	proc_cntx = (nrand48(xsub1));
	CPU_SET(proc_cntx % proc_cnt, &mask);
	sched_setaffinity(0, sizeof(cpu_set_t), &mask);

	/*
	printf("\nPROCESS AFFINITY MASK AFTER ADJUSTMENT:\n");

	sched_getaffinity(syscall(SYS_gettid), sizeof(cpu_set_t), &mask);
	sprintf(wr_buf, " %s: %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d\n\n", "    ",
		(CPU_ISSET(0, &mask)) ? 1 : 0,
		(CPU_ISSET(1, &mask)) ? 1 : 0,
		(CPU_ISSET(2, &mask)) ? 1 : 0,
		(CPU_ISSET(3, &mask)) ? 1 : 0,
		(CPU_ISSET(4, &mask)) ? 1 : 0,
		(CPU_ISSET(5, &mask)) ? 1 : 0,
		(CPU_ISSET(6, &mask)) ? 1 : 0,
		(CPU_ISSET(7, &mask)) ? 1 : 0,
		(CPU_ISSET(8, &mask)) ? 1 : 0,
		(CPU_ISSET(9, &mask)) ? 1 : 0,
		(CPU_ISSET(10, &mask)) ? 1 : 0,
		(CPU_ISSET(11, &mask)) ? 1 : 0,
		(CPU_ISSET(12, &mask)) ? 1 : 0,
		(CPU_ISSET(13, &mask)) ? 1 : 0,
		(CPU_ISSET(14, &mask)) ? 1 : 0,
		(CPU_ISSET(15, &mask)) ? 1 : 0,
		(CPU_ISSET(16, &mask)) ? 1 : 0,
		(CPU_ISSET(17, &mask)) ? 1 : 0,
		(CPU_ISSET(18, &mask)) ? 1 : 0,
		(CPU_ISSET(19, &mask)) ? 1 : 0,
		(CPU_ISSET(20, &mask)) ? 1 : 0,
		(CPU_ISSET(21, &mask)) ? 1 : 0,
		(CPU_ISSET(22, &mask)) ? 1 : 0,
		(CPU_ISSET(23, &mask)) ? 1 : 0);

	write(1, wr_buf, strlen(wr_buf));*/

	gettimeofday(&first_time, (struct timezone*)0);
	for (i = 0; i < (NUMCONSUMERS + NUMPRODUCERS); i++)
		arg_array[i] = i + 1;

	// Initialize all of our mutexes, conditions, in and out pointers, serials, space counts,
	// and donut counts.
	for (i = 0; i < NUMFLAVORS; i++){
		pthread_mutex_init(&prod[i], NULL);
		pthread_mutex_init(&cons[i], NULL);
		pthread_cond_init(&prod_cond[i], NULL);
		pthread_cond_init(&cons_cond[i], NULL);
		the_store.out_ptr[i]     = 0;
		the_store.in_ptr[i]      = 0;
		the_store.serial[i]      = 0;
		the_store.space_count[i] = NUMSLOTS;
		the_store.donut_count[i] = 0;
	}

	gettimeofday(&randtime, (struct timezone *)0);

	// sigfillset initializes the signal set all_signals to include all of the defined signals.  
	// The return value is 0.
	sigfillset(&all_signals);
	// nsigs is the number of asynchronous signals in our signal set.
	nsigs = sizeof(sigs) / sizeof(int);

	// Ask prof Moloney
	for (i = 0; i < nsigs; i++)
		sigdelset(&all_signals, sigs[i]);
	sigprocmask(SIG_BLOCK, &all_signals, NULL);

	for (i = 0; i < nsigs; i++){
		new.sa_handler = sig_handler;
		new.sa_mask = all_signals;
		new.sa_flags = 0;
		if (sigaction(sigs[i], &new, NULL) == -1){
			perror("cannot set signals: ");
			exit(1);
		}
	}

	// creating a waiting signaler thread, wake up if we receive an asynchronous signal.
	if ((errno = pthread_create(&sig_wait_id, NULL, sig_waiter, NULL)) != 0){
		perror("pthread_create failed ");
		exit(3);
	}

	// initializes attribute for default behavior
	pthread_attr_init(&thread_attr);
	pthread_attr_setinheritsched(&thread_attr, PTHREAD_INHERIT_SCHED);

// Shows us how to use an attribute structure
#ifdef GLOBAL
	sched_struct.sched_priority = sched_get_priority_max(SCHED_OTHER);
	pthread_attr_setinheritsched(&thread_attr, PTHREAD_EXPLICIT_SCHED);
	pthread_attr_setschedpolicy(&thread_attr, SCHED_OTHER);
	pthread_attr_setschedparam(&thread_attr, &sched_struct);
	pthread_attr_setscope(&thread_attr, PTHREAD_SCOPE_SYSTEM);
#endif

	// create pthreads for all our producers
	for (i = 1; i < NUMCONSUMERS+1; i++){
		if ((errno = pthread_create(&thread_id[i], &thread_attr, producer, (void *)&arg_array[i])) != 0){
			perror("pthread_create failed ");
			exit(3);
		}
	}/*
	// create pthreads for all our consumers
	first_consumer_thread_index = i;
	for (; i < (NUMCONSUMERS + NUMPRODUCERS); i++){
		if ((errno = pthread_create(&thread_id[i], &thread_attr, consumer, (void*)&arg_array[i - NUMPRODUCERS])) != 0){
			perror("pthread_create consumers failed ");
			exit(3);
		}
	}
	// pthread join all our consumers and producers
	/* pthread function waits for the thread specified by thread_id[i] to terminate.  If that thread
	has already terminated, then this function returns immediately*/
	/*for (i = first_consumer_thread_index; i < (NUMCONSUMERS + NUMPRODUCERS); i++){
		pthread_join(thread_id[i], NULL);
		// write statements print out immediately as opposed to printf statements which print out
		// whenever is convenient for the system.
		write(STDOUT, "*", 1);
		}*/
	// Elapsed time arithmetic
	gettimeofday(&last_time, (struct timezone *)0);
	if ((i = last_time.tv_sec - first_time.tv_sec) == 0)
		j = last_time.tv_usec - first_time.tv_usec;
	else{
		if (last_time.tv_usec - first_time.tv_usec < 0){
			i--;
			j = 1000000 + (last_time.tv_usec - first_time.tv_usec);
		}
		else{
			j = last_time.tv_usec - first_time.tv_usec;
		}
	}
	printf("\n\nElapsed consumer time is %d sec and %d usec, or %f sec\n", i, j, (etime = i + (float)j / 1000000));
	if ((cn = open("./proc_times", O_WRONLY | O_CREAT | O_APPEND, 0644)) == -1){
		perror("can not open proc time file");
		exit(1);
	}
	sprintf(msg, "%f\n", etime);
	write(cn, msg, strlen(msg));
	printf("\nALL CONSUMERS FINISHED, NORMAL PROCESS EXIT\n\n");
	exit(0);
}

void *producer(void *arg)
{
	short i, j, len;
	float etime;
	char msg[100];
	ushort xsub1[3];
	struct timeval randtime;
	int cn;
	char thread_number[5];

	// seed our random number generator
	gettimeofday(&randtime, (struct timezone *)0);
	xsub1[0] = (ushort)randtime.tv_usec;
	xsub1[1] = (ushort)(randtime.tv_usec >> 16);
	xsub1[2] = (ushort)(getpid());

	while (1){
		j = nrand48(xsub1) & 3;
		pthread_mutex_lock(&prod[j]);

		while (the_store.space_count[j] = 0){
			pthread_cond_wait(&prod_cond[j], &prod[j]);
		}

		the_store.donut_ring_buffers[j][the_store.in_ptr[j]].serial_number = the_store.serial[j];
		the_store.donut_ring_buffers[j][the_store.in_ptr[j]].producer_id = *(int *)arg;
		the_store.in_ptr[j] = (the_store.in_ptr[j] + 1) % NUMSLOTS;
		the_store.serial[j]++;

		pthread_mutex_unlock(&prod[j]);
/*
		if (the_store.serial[j] % 120 == 0)
		{
			sprintf(msg, "producer %d finishes 10 dozen %ds\n", *(int *)arg, j);
			len = strlen(msg);
			write(STDOUT, msg, len);
		}*/

		pthread_mutex_lock(&cons[j]);
		the_store.donut_count[j]++;
		pthread_mutex_unlock(&cons[j]);

		// if there was a consumer waiting on the condition variable, we wake him up
		pthread_cond_signal(&cons_cond[j]);
	}
	return NULL;
}

void *consumer(void *arg)
{
	donut_t extracted_donut;
	short f, s, i, j, m, id, len;
	char msg[100], lbuf[5];
	ushort xsub1[3];
	struct timeval randtime;
	int cn;
	struct tm* pTime;
	long milliseconds;
	char tstr[9];
	short printmatrix[NUMFLAVORS][12];
	short count[4];
	unsigned cpu;
	char number[2] = { '\060', '\n' };
	// name of our consumer file
	char file_name[5] = "cons";
	char thread_number[5];
	unsigned int cpusetsize;
	cpu_set_t mask;
	struct timespec dozen_delay;

	dozen_delay.tv_sec = 0;
	dozen_delay.tv_nsec = 100;

	// seed randtime
	gettimeofday(&randtime, (struct timezone *)0);
	xsub1[0] = (ushort)randtime.tv_usec;
	xsub1[1] = (ushort)(randtime.tv_usec >> 16);
	xsub1[2] = (ushort)(getpid());

	/*
	sched_getaffinity(syscall(224), sizeof(cpusetsize), &mask);
	for (i = 0; i < 8; i++){
		printf("Thread ID is %d PT_self is %d PID is %d CPU_ID %d %s\n",
			syscall(224), pthread_self(), getpid(), i, (CPU_ISSET(i, &mask)) ? "exists" : "does not exist");
	} */

	id = *(int *)arg;
	sprintf(lbuf, " %d", id);


	sprintf(file_name, "cons%03d", id);
	if ((cn = open(file_name, O_WRONLY | O_CREAT, 0666)) == -1){
		perror("failed to open cons log ");
	}

	// outer loop for number of dozens
	for (i = 0; i < NUM_DOZ_TO_CONS; i++){
		/*
		if (id == 2){
			sprintf(msg, "cpu %d\n", sched_getcpu());
			syscall(318, &cpu, NULL, NULL);
			sprintf(msg, "cpu %d\n", cpu);
			write(cn, msg, strlen(msg));
		} */

		if (i <= 9){
			// clear out printmatrix
			for (f = 0; f < NUMFLAVORS; f++){
				for (s = 0; s < 12; s++)
					printmatrix[f][s] = -1;
			}
			// reset count
	 		for (s = 0; s < NUMFLAVORS; s++)
				count[s]=0;
		}

		// start of inner loop
		for (m = 0; m < 12; m++){
			j = nrand48(xsub1) & 3;
			pthread_mutex_lock(&cons[j]);
			while (the_store.donut_count[j] == 0){
				pthread_cond_wait(&cons_cond[j], &cons[j]);
			}
			the_store.donut_count[j]--;
			extracted_donut = the_store.donut_ring_buffers[j][the_store.out_ptr[j]];
			// fill in printmatrix and increment count
			if (i <= 9){
				printmatrix[j][count[j]]= the_store.out_ptr[j];
				count[j]++;
			}
			the_store.out_ptr[j] = (the_store.out_ptr[j] + 1) % NUMSLOTS;
			pthread_mutex_unlock(&cons[j]);

			pthread_mutex_lock(&prod[j]);
			the_store.space_count[j]++;
			pthread_mutex_unlock(&prod[j]);

			pthread_cond_signal(&prod_cond[j]);
		}		

		if (i <= 9){
			// get time
			pTime = localtime(&randtime.tv_sec);
	 		strftime(tstr, sizeof(tstr), "%H:%M:%S", pTime);
			milliseconds = randtime.tv_usec / 1000;
			// Print out header for new dozen
			sprintf(msg, "Consumer thread # %d\t time: %s.%ld\t dozen #: %d\n\n", id, tstr, milliseconds, i+1);
			write(cn, msg, strlen(msg));
			// flavors of donuts
			sprintf(msg, "plain\t\tjelly\t\tcoconut\t\thoney-dip\n");
			write(cn, msg, strlen(msg));

			for (s = 0; s < 12; s++){
				for (f = 0; f < NUMFLAVORS; f++){
					if (printmatrix[f][s] != -1){
						sprintf(msg, "%d\t\t", printmatrix[f][s]);
						write(cn, msg, strlen(msg));
					}else{
						sprintf(msg, "\t\t");
						write(cn, msg, strlen(msg));
					}
				}
				sprintf(msg, "\n");
				write(cn, msg, strlen(msg));
	 		}
			sprintf(msg, "-----------------------------------------------------------\n\n");
			write(cn, msg, strlen(msg));
		}

		printf("%d", i);
		
		/