<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en"><html>  <head>    <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">    <meta name="GENERATOR" content="Mozilla/4.5 [en] (Win98; I) [Netscape]">    <meta name="Author" content="Jonathan Shapiro">    <title>CMPSCI 453: Programming Assignment 3</title>  </head>  <body bgcolor="#ffffff"> <spacer type="vertical" size="15">      <p> </p>      <hr>      <p><span style="font-weight: bold;">Programming Assignment 2: Distributed          Asynchronous Distance Vector Routing</span> </p>      <p><b>Overview</b> </p>      <p>In this programming assignment, you will be writing a ``distributed''        set of procedures that implement a distributed asynchronous distance        vector routing for the network shown below. </p>      <center>        <p><img style="width: 283px; height: 208px;" alt="" src="pa2extra/pa2fig1.gif"></p>      </center>      <p><b>The Basic Assignment</b> </p>      <p><b>The routines you will write</b> For the basic part of the        assignment, you are to write the following routines which will        ``execute'' asynchronously within the emulated environment that I have        written for this assignment. </p>      <p>For node 0, you will write the routines: </p>      <ul>        <li> <tt>rtinit0()</tt> This routine will be called once at the          beginning of the emulation. <tt>rtinit0()</tt> has no arguments. It          should initialize the distance table in node 0 to reflect the direct          costs of 1, 3, and 7 to nodes 1, 2, and 3, respectively. In Figure 1,          all links are bi-directional and the costs in both directions are          identical. After initializing the distance table, and any other data          structures needed by your node 0 routines, it should then send its          directly-connected neighbors (in this case, 1, 2 and 3) the cost of it          minimum cost paths to all other network nodes. This minimum cost          information is sent to neighboring nodes in a <i>routing packet</i>          by calling the routine <tt>tolayer2(),</tt> as described below. The          format of the routing packet is also described below.</li>        <br>        <br>        <li> <tt>rtupdate0(struct rtpkt *rcvdpkt)</tt>. This routine will be          called when node 0 receives a routing packet that was sent to it by          one if its directly connected neighbors. The parameter <tt>*rcvdpkt</tt>          is a pointer to the packet that was received.&nbsp; </li>        <p><tt>rtupdate0()</tt> is the ``heart'' of the distance vector          algorithm. The values it receives in a routing packet from some other          node <i>i</i> contain <i>i</i>'s current shortest path costs to all          other network nodes. <tt>rtupdate0()</tt> uses these received values          to update its own distance table (as specified by the distance vector          algorithm). If its own minimum cost to another node changes as a          result of the update, node 0 informs its directly connected neighbors          of this change in minimum cost by sending them a routing packet.          Recall that in the distance vector algorithm, only directly connected          nodes will exchange routing packets. Thus nodes 1 and 2 will          communicate with each other, but nodes 1 and 3 will node communicate          with each other. </p>        <p>As we saw in class, the distance table inside each node is the          principal data structure used by the distance vector algorithm. You          will find it convenient to declare the distance table as a 4-by-4          array of <tt>int</tt>'s,          where entry <tt>[i,j] </tt>in the distance table in node 0 is node          0's currently computed cost to node i via direct neighbor j. If 0 is          not directly connected to <i>j,</i> you can ignore this entry. We          will use the convention that the integer value 999 is ``infinity.'' </p>        <p>The figure below provides a conceptual view of the relationship of          the procedures inside node 0. </p>        <center><img alt="" src="pa2extra/pa2fig2.gif" style="border: 0px solid ; width: 384px; height: 353px;"></center>      </ul>      Similar routines are defined for nodes 1, 2 and 3. Thus, you will write 8      procedures in all: <tt>rtinit0(), rtinit1(), rtinit2(),        rtinit3(),rtupdate0(), rtupdate1(), rtupdate2(), rtupdate3()</tt> <br>      &nbsp; &nbsp;      <p><b>Software Interfaces</b> </p>      <p>The procedures described above are the ones that you will write. I have        written the following routines which can be called by your routines: </p>      <dl>        <dt> <tt>tolayer2(struct rtpkt pkt2send)</tt></dt>        <dd> where <tt>rtpkt</tt> is the following structure, which is already          declared for you. The procedure <tt>tolayer2()</tt> is defined in the          file <a href="pa2extra/prog3.c">prog3.c</a></dd>        <pre><tt>extern struct rtpkt {<br>&nbsp; int sourceid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* id of node sending this pkt, 0, 1, 2, or 3&nbsp; */<br>&nbsp; int destid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* id of router to which pkt being sent&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (must be an immediate neighbor) */<br>&nbsp; int mincost[4];&nbsp;&nbsp;&nbsp; /* min cost to node 0 ... 3 */<br>&nbsp; };</tt></pre>        Note that <tt>tolayer2() </tt>is passed a structure, not a pointer to        a structure. <dt><tt>printdt0()</tt></dt>        <dd> will pretty print the distance table for node 0. It is passed a          pointer to a structure of type <tt>distance_table.</tt> <tt>printdt0()</tt>          and the structure declaration for the node 0 distance table are          declared in the file <tt>node0.c.</tt> Similar pretty-print routines          are defined for you in the files <tt>node1.c, node2.c node3.c.</tt></dd>        &nbsp;      </dl>      <b>The simulated network environment</b>      <p>Your procedures <tt>rtinit0(), rtinit1(), rtinit2(), rtinit3()</tt>        and <tt>rtupdate0(), rtupdate1(), rtupdate2(), rtupdate3()</tt> send        routing packets (whose format is described above) into the medium. The        medium will deliver packets in-order, and without loss to the specified        destination. Only directly-connected nodes can communicate. The delay        between is sender and receiver is variable (and unknown). </p>      <p>When you compile your procedures and my procedures together and run the        resulting program, you will be asked to specify only one value regarding        the simulated network environment: </p>      <ul>        <li> <b>Tracing.</b> Setting a tracing value of 1 or 2 will print out          useful information about what is going on inside the emulation (e.g.,          what's happening to packets and timers). A tracing value of 0 will          turn this off. A tracing value greater than 2 will display all sorts          of odd messages that are for my own emulator-debugging purposes.</li>        <p>A tracing value of 2 may be helpful to you in debugging your code.          You should keep in mind that <i>real</i> implementors do not have          underlying networks that provide such nice information about what is          going to happen to their packets!</p>      </ul>      <b>The Basic Assignment</b>      <p>You are to write the procedures <tt>rtinit0(), rtinit1(), rtinit2(),          rtinit3()</tt> and <tt>rtupdate0(), rtupdate1(), rtupdate2(),          rtupdate3()</tt> which together will implement a distributed,        asynchronous computation of the distance tables for the topology and        costs shown in Figure 1. </p>      <p>You should put your procedures for nodes 0 through 3 in files called        node0.c, .... node3.c. You are <b>NOT</b> allowed to declare any global        variables that are visible outside of a given C file (e.g., any global        variables you define in <tt>node0.c.</tt> may only be accessed inside <tt>node0.c</tt>).
This
        is to force you to abide by the coding conventions that you would have        to adopt is you were really running the procedures in four distinct        nodes. To compile your routines: <tt>cc prog3.c node0.c node1.c node2.c          node3.c.&nbsp;</tt> Here are the links to the prototype version of the        node files, and my emulator file, <tt>prog3.c:</tt> <br>        <tt><a href="pa2extra/prog3.c">http://gaia.cs.umass.edu/cs453/hwpa/prog3.c</a></tt>        <br>        <tt><a href="pa2extra/node0.c">http://gaia.cs.umass.edu/cs453/hwpa/node0.c</a></tt>        <br>        <tt><a href="pa2extra/node1.c">http://gaia.cs.umass.edu/cs453/hwpa/node1.c</a></tt>        <br>        <tt><a href="pa2extra/node2.c">http://gaia.cs.umass.edu/cs453/hwpa/node2.c</a></tt>        <br>        <tt><a href="pa2extra/node3.c">http://gaia.cs.umass.edu/cs453/hwpa/node3.c</a></tt>      </p>      <p><b>This assignment can be completed on any machine supporting C. It          makes no use of UNIX features.</b> </p>      <p>As always, you should hand in a code listing, a design document (as        described in the handout accompanying the first programming assignment),        and sample output. </p>      <p>For your sample output, your procedures should print out a message        whenever your<tt>rtinit0(), rtinit1(), rtinit2(), rtinit3()</tt> or <tt>rtupdate0(),
          rtupdate1(), rtupdate2(), rtupdate3()</tt> procedures are called,        giving the time (available via my global variable <tt>clocktime</tt>).        For <tt>rtupdate0(),          rtupdate1(), rtupdate2(), rtupdate3()</tt> you should print the        identity of the sender of the routing packet that is being passed to        your routine, whether or not the distance table is updated, the contents        of the distance table (you can use my pretty-print routines), and a        description of any messages sent to neighboring nodes as a result of any        distance table updates. </p>      <p>The sample output should be an output listing with a TRACE value of 2.        Highlight the final distance table produced in each node. Your program        will run until there are no more routing packets in-transit in the        network, at which point my emulator will terminate.        <!-----------------------------------------<p><b>Extra credit Assignment</b><p>You are to write two procedures,<tt>rtlinkhandler0(int linkid, intnewcost)</tt> and <tt>rtlinkhandler1(int linkid, int newcost)</tt>, whichwill be called if (and when) the cost of the link between 0 and 1 changes.These routines should be defined in the files <tt>node0.c</tt> and <tt>node1.c,</tt>respectively. The routines will be passed the name (id) of the neighboringnode on the other side of the link whose cost has changed, and the newcost of the link. Note that when a link cost changes, these routines willhave to update the distance table and may (or may not) have to send updatedrouting packets to neighboring nodes.<p>In order to complete the exrta credit part of the assignment, you willneed to change the value of the constant LINKCHANGES (line 3 in<tt>prog3.c</tt>to 1. FYI, the cost of the link will change from 1 to 20 at time 10000and then change back to 1 at time 20000. Your routines will be invokedat these times.<p>I would again <b>STRONGLY</b> recommend that you first implement thebasic assignment and then extend your code to implement the extra creditassignment. It will <b>not</b> be time wasted. ----------------------------------------></p>      <p></p>      <hr width="100%">      <p><font color="#ff0000"><font size="+1">JAVA version of Programming            Assignment 3</font></font> </p>      <p>The documentation above describes the project in detail.&nbsp; Here we        provide a link to the code needed to do the assignment in JAVA.&nbsp;        Make sure you understand the material above. </p>      <p>Here are the links to the JAVA code you'll need: </p>      <blockquote><a href="pa2extra/Entity.java">Entity.java</a>,&nbsp; <a href="pa2extra/Entity0.java">Entity0.java</a>,        <a href="pa2extra/Entity1.java">Entity1.java</a>,&nbsp;&nbsp; <a href="pa2extra/Entity2.java">Entity2.java</a>,        <a href="pa2extra/Entity3.java">Entity3.java</a>,&nbsp; <a href="pa2extra/NetworkSimulator.java">NetworkSimulator.java</a>,        <a href="pa2extra/Event.java">Event.java</a>, <a href="pa2extra/Packet.java">Packet.java</a>,&nbsp;
        <a href="pa2extra/EventList.java">EventList.java</a>,&nbsp; <a href="pa2extra/EventListImpl.java">EventListImpl.java</a>,        <a href="pa2extra/Project.java">Project.java</a></blockquote>      You'll the write the constructors of Entity0.java, Entity1.java,      Entity2.java, and Entity3.java&nbsp; which are analgous to rtinit0(),      rtinit1(), rtinit2() and rtinit3() in the C version. You will also need to      write the update() methods for Entity0.java, Entity1.java, Entity2.java,      and Entity3.java&nbsp; which are analgous to&nbsp; rtupdate0(),      rtupdate1(), riupdate2() and rtupdate3() in the C version.      <p>Note that the Java code will allow yu to hang yourself by sending        incorrect packets via the toLayer2() method of NetworkSimulator.&nbsp;        So please be extra careful there. <br>        &nbsp; </p>      <address></address>      <hr width="100%">      <address><i>jshapiro@gaia.cs.umass.edu</i></address>      <br>      &nbsp; </spacer>  </body></html>